# 第一章-----python入门

## 1.1python是什么

Python是一个简单、易读、易记的编程语言，而且是开源的，可以免 费地自由使用

## 1.2python安装

> python3.x与2.x不兼容

### 1.2.2使用的外部库

Numpy库：数值计算库

Matplotlib库：画图的库，将实验结果可视化

## 1.3python解释器

在终端中输入 `python --version` 可以确定python版本

### 1.3.2数据类型

数据类型表示数据的性质，有整数（int）、小数（float）、字符串（str）等，可以使用type来查看

> 是注释 其后面的文字会被忽略

### 1.3.3变量

可以使用26个英文字母定义变量，同时可以给变量赋值，以及计算

 Python是属于“动态类型语言”的编程语言，所谓动态，是指变量的类 型是根据情况自动决定的。

### 1.3.4列表

可以汇总数据，类似于数组

索引是从0开始，python内部提供切片便于找到所找的数据

> -1代表最后一个元素
>
> -2代表倒数第二个元素

### 1.3.5字典

索引同样从0开始，每一个值都可以有一个key去寻找他

### 1.3.6布尔型

返回值只有false或者true，即0/1。

### 1.3.7if语句

`if...else` 当前面的条件（if hungry） 成立时，此处的代码会被执行

需要控制缩进tab

### 1.3.8for语句

for通常与in构成循环  `for... in ... :  语句结构`

## 1.4脚本文件

### 1.4.1保存为文件

创建的文件名后缀为py

> python  x.py 就可以执行此程序

### 1.4.2类

自己定义一个新的类型

``` py
class 类名：    

	def __init__(self, 参数, …): # 构造函数 只在生成类的实例时被调用一次      

		...    

	def 方法名1(self, 参数, …): # 方法1       

		...    

	def 方法名2(self, 参数, …): # 方法2
		...
```

## 1.5NumPy

作用：便捷数组和矩阵的计算

### 1.5.1导入NumPy

``` python
import numpy as np # 将numpy 作为np导入
```

### 1.5.2生成NumPy

```python
# 生成numpy数组需要使用np.array()
x = np.array([1.0,2.0,3.0])
--> [1. 2. 3.]

type(x)
--> <class 'numpy.ndarray'>
```

### 1.5.3Numpy的算数运算

两个数组之间运算：

- 元素个数相同--> 一一对应做相应的运算
- 元素个数不同--> 报错

数组对单一数值也可以进行运算：

- 分别进行运算

### 1.5.4Numpy的N维数组

可以生成多维数组并且可以进行运算，

一维数组--->向量，二维数组---> 矩阵，三维数组即以上--->张量/多维数组

可以将一般化之后的向量或矩阵等统 称为张量

> shape 可以查看矩阵形状
>
> dtype 可以查看矩阵元素的数据类型

其运算与数组运算一样，可以在相同形状下对应元素进行运算，也可以在通过标量对矩阵进行算术运算

### 1.5.5广播

在矩阵和标量相乘时，将标量扩展成与矩阵相同形状的一个矩阵(将标量变成二维数组进行运算)

因为NumPy有广播功能，所以不同形状的数组之间也可以进行运算。eg：

```python
x = np.array([[1, 2],[3, 4]])
y = np.array([10, 20])
--> array([[ 10, 40],
       		[ 30, 80]]) 
```

### 1.5.6访问元素

索引从0开始,与c语言一致

对各个元素访问

方法一：

```python
#通过索引找
x = np.array([[51, 55], [14, 19], [0, 4]])
print(x[0])
--> [51, 55]
```

方法二：

```python
# for循环
for i in x：
	print(i)
```

方法三：

```python
# numpy可以使用数组访问各个元素
X = x.flatten()   #将x转换为一维数组
```

## 1.6 Matplotlib

Matplotlib是用于绘制图形的库，使用Matplotlib可以绘制图形和实现数据的可视化

### 1.6.1绘制简单图形

```python
# sin曲线：
import numpy as np
import matplotlib.pyplot as plt

 # 生成数据
x = np.arange(0, 6, 0.1)   # 以0.1为单位，生成0到6的数据
y = np.sin(x)  #应用numpy的sin函数

# 绘制图形
 plt.plot(x, y)
 plt.show()
```

> arange 返回一个有终点和起点的固定步长的排列(等差数组)
>
> plot(x,y) 绘制二维图像
>
> show 将图形展示出来

### 1.6.2pyplot

```python
import numpy as np
import matplotlib.pyplot as plt

# 生成数据
x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据
y1 = np.sin(x)
y2 = np.cos(x)

# 绘制图形
plt.plot(x, y1, label="sin")
plt.plot(x, y2, linestyle = "--", label="cos") # 用虚线绘制
plt.xlabel("x") # 添加x轴标签
plt.ylabel("y") # 添加y轴标签
plt.title('sin & cos') # 标题
plt.legend()  #在图形上显示图例。由于之前为两条线分别设置了标签"sin"和"cos"，所以图例会显示这两条线的标签。
plt.show()
```

### 1.6.3显示图像

```py
import matplotlib.pyplot as plt
from matplotlib.image import imread

img = imread('lena.png') # 读入图像（设定合适的路径！）
plt.imshow(img)
plt.show()
```

imshow展示图像

## 1.7小结

- 认识数据类型，python基础的学习
- numpy库的导入和使用，array，arange，sin，cos
- matplotlib绘制图像，以及其内部函数的使用。plot，show，title，legend，image，show

# 第二章-----感知机

学习感知机的构造也就是学习通向神经网络和深度学习的一种重要思想

## 2.1感知机是什么

感知机接受输入多个信号，输出一个信号（类似于生物中的电信号）

**神经元激活**:传送过来的信号总和超过**某个限制(阈值)**才会输出1（0：不流，1：流）

多个输入信号都有各自固有的权重，权重越大重要性越高，与电阻(信号)电流(权重)的关系相似

## 2.2简单逻辑电路

### 2.2.1与门

与门：有两个输入和一个输出的门电路。当x1，x2均为1时，y为1

输入信号和输出信号的对应表称为**真值表**

### 2.2.2　与非门和或门

与非门：颠倒了与门的输出。当x1，x2均为1时，y为0

把实现与门的参数值的符号取反， 就可以实现与非门。

或门：只要有一个是1输出就是1

> 学习是确定合适的参数的过程，而人要做的是思考感知机的构造（模型），并把 训练数据交给计算机

2.2.3 总结

与门、与非门、或门的感知机构造是一样的，只有权重和阈值不同

## 2.3感知机的实现

### 2.3.1简单实现：

```python
def use(x1,x2):
    w1, w2, theta = 0.5, 0.5, 0.8
    t = x1*w1 + x2*w2
    if t <= t:
        return 0
    else:
        return 1
print(use(0, 0), use(1,1))
```

### 2.3.2导入权重和偏置

上述感知器实现流入均是大于theta，将theta = -b，则`x1*w1 + x2*w2 >= theta`----->`b + x1*w1 + x2*w2 >= 0`

而b则是偏置

> np.sum可以计算各个元素的总和

### 2.3.3使用权重和偏置的实现

偏置是调整神经元被激活的容易程度(输出信号为1的程度)的参数,是其激活的零界点

与门

```py
def AND(x1, x2):
    m = np.array([x1, x2])
    n = np.array([0.5, 0.5])
    b = -0.7
    t = np.sum(m*n) + b
    if t >= 0:
        return 1
    else:
        return 0
```

与非门

> 实现与门的参数值的符号取反， 就可以实现与非门。

```py
def NAND(x1, x2):
    m = np.array([x1, x2])
    n = np.array([-0.5, -0.5])
    b = 0.7
    t = np.sum(m*n) + b
    if t >= 0:
        return 1
    else:
        return 0
```

或门

> 仅权重和偏置不同

```py
def OR(x1, x2):
    m = np.array([x1, x2])
    n = np.array([0.5, 0.5])
    b = -0.2
    t = np.sum(m*n) + b
    if t <= 0:
        return 0
    else:
        return 1
```

## 2.4感知机的局限性

### 2.4.1异或门

异或门又称**逻辑异或**，仅当x1或x2一个为1才会输出1

发现：`d + x1*w1 + w2*x2 >=0`用线性知识无法实现，我们无法做出一条直线分割(0, 0)和(1, 1)

所以仅单层感知机无法表示异或门

### 2.4.2线性和非线性

**感知机的局限性**：只能由一条直线分割

非线性空间：曲线分割而成的空间

线性空间：直线分割而成的空间

## 2.5多层感知机

通过叠加层表示异或门

### 2.5.1已有门电路的组合

用已学的门电路实现异或门：

x1---------NAND------->s1 ---

​        |                                   |-------- AND -------->y

x2----------OR----------->s2 ---

### 2.5.2异或门的实现

```py
def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y
```

**多层感知机**：叠加了多层的感知机

多层感知机的实现：（2层感知机举例）

- 第0层的两个神经元接收输入信号，并将信号发送至第1层的神经元
- 第1层的神经元将信号发送至第2层的神经元，第2层的神经元输出y

通过叠加层使感知机进行更加灵活的表示

## 2.6从非与门到计算机

多层感知机可以表示计算机进行的处理，合理但是繁琐

### 2.7总结

感知机是什么：机是具有输入和输出的算法，一种二元分类模型

与门：x1与x2均为1 ----> y = 1，其余y均为0

与非门：x1与x2均为1 ----->y = 0，其余y均为0

或门：只要有1----->y就为1

异或门：当且仅当其中一个为1------>y才为1                2层感知机

# 第三章神经网络

解决设定合适且符合预期的输入与输出的权重
