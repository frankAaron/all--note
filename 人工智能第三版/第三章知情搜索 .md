# 第三章：知情搜索 

## 3.1启发式方法

- **启发式方法**的目的是大幅度减少到达目标状态所要考虑的节点数目，它们非常适合解决那些**组合复杂度**快速增长的问题。通过知识、信息、规则、见解、类比和简化，再加上一系列其他的技术，启发式方法旨在**减少必须检查的对象数目** 。好的启发式方法不能保证一定获得解，但是它们经常有助于人们找到到达解的路径。

- 朱迪亚·珀尔：**算法**是确定性的方法，旨在通过明确定义的一系列步骤来求解问题。而启发式方法更凭直觉，是一种更类似于人的方法：它们**基于洞察**、**经验和专业知识**。它们可能是描述人类求解问题的方法和途径的最好方式，这与机器类方法明显不同

- 珀尔注意到：使用启发式方法可以通过修改策略来达到一个准最优（非最优）解，同时代价得以显著降低。博弈，特别是二人完美信息（perfect information）零和博弈（zero-sum game），如国际象棋和跳棋等，被证明是进行启发式方法研究和测试的一个非常有前途的领域。

techtarget 网站对“heuristic”进行了如下定义：

**作为形容词**，“heurisitc”与通过智能猜测获取知识或某个期望结果的过程有关，而该过程并不遵循某些预先建立的公式来进行。有两种用法：

（1）描述了一种学习方法，这种学习方法的尝试不需要一个安排好的假设，也不需要证明结果是否符合这个假设。也就是说，这是一种“凭经验”或基于“试错”的学习方式

（2）与通过经验获得的一般性知识的使用有关，有时候表达为“使用经验法则”（但是，启发式知识既可以应用于复杂问题，也可以应用于简单的日常问题。人类棋手使用的就是启发式方法）。 

 **作为名词**，指的是某条具体的经验法则或来自经验的论证。启发式知识在某个问题上的应用有时候被称为启发式方法。对启发式搜索的一些定义：

- 它是提高复杂问题求解效果的一种实用策略。
- 它引导程序沿着一条最可能的路径到达最终解，而忽略那些最没有希望的路径。  
- 它应该能够避免去检查“死路径”，并且只使用已收集到的数据。  我们可以将启发式信息以如下方式添加到搜索中。  

将启发式信息以如下方式添加到搜索中：

- 决定接下来要扩展的节点，而不是严格按照广度优先或深度优先的方式进行扩展。  
- 在生成节点的过程中，决定生成哪个或哪些后继节点，而不是一次性生成所有可能的 后继节点。  
- 确定哪些节点应该从搜索树中丢弃或裁剪。 

***注：启发式方法只是一种“经验法则”***

## 3.2知情搜索（第一部分）——找到任一解

### 3.2.1 爬山法

在爬山过程中，即使可能更接近顶部的目标节点，也可能无法从当前位置到达目标/目的地。换句话说，爬山者可能接近了一个目标状态，却无法到达。爬山法一般是要讨论的第一个知情搜索算法。最简单形式的爬山法是一种贪心算法，因为它**没有历史意识，也没有能力从错误或错误路径中恢复**。它会使用某种衡量指标（不管是最大化还是最小化这种衡量指标）来引导自己到达目标并确定下一步的选择

缺点：做出决策的过程（启发式衡量指标或称启 发式函数）太过朴素简单，以至于爬山者**没有真正足够的信息**来确定自己是否在正确的路径上。

### 3.2.2  最陡爬山法

**最陡爬山法**（steepest-ascent hill climbing）是简单爬山法的一个变体，它考虑到做出能够更加接近某个目标状态，并且是从多个可能的选项中做出的最佳决策。相较于简单爬山法。这种方法在选择优于当前状态的第一状态时有所不同。与仅仅选择一个优于当前状态的“一步”不同，这种方法是在所有给定的可能状态集合中选择“最优”的一步

#### **1.山岳问题**

爬山法是一种贪心算法，对过去和未来都没有意识，因此它可能会陷入局部最大值（local  maximum），这意味着虽然最终解或目标状态似乎可达（甚至可以看到），但是并不能从当前位 置到达，即使当前所在山丘的顶部是可见的

#### **2.平台问题**

即状态空间中存在一个相对平坦的区域，使得相邻的状态都具有相同的值。一个较大幅度的跳跃往往才能离开这个平坦的区域

#### **3.山脊问题**

在这个问题中，不管向下往哪个方向移动，山脊上的任何一点都看起来像山峰顶点，因为任何方向的移动都是向下的



- 对于爬山法中的上述问题，有一些缓解方法可以尝试。解决局部最大值问题的一种方法是 回溯到前面的节点，并尝试不同的方向。考虑那些很可能选择的路（尤其是在最陡爬山法中），如果这条路是死路，那就考虑另一条路

- 当相邻区域内有许多点具有相似值时，平台问题就会出现。处理这个问题的最好方法是， 通过多次应用相同的规则，尝试到达搜索空间的新区域。用这种方式就可以产生新的极端的值

- 最后，通过同时应用几个规则并在多个方向上进行搜索，有助于避免导致山脊问题的各种值。可在早期就经常沿着多个方向搜索，从而防止搜索被陷在某个位置

## 3.3   最佳优先搜索

在爬山法的基础上考虑可能的补救措施并对其进行某种程度的形式化处理，我们就可以得到**最佳优先搜索**。为到达目标而考虑探索哪些节点以及探索多少个节点，维护开放节点及封闭节点列表。开放节点是搜索**边缘**（fringe）上的节点，后面可能会进一步探索到。而封闭节点是那些不再探索的节点，它们将构成解的基础。在开放列表中，节点按照它们接近目标状态的启发式估计值大小进行排列。因此，每次迭代搜索时，都会考虑开放列表中最有希望的节点，从而将最佳状态放在开放列表的前端。重复状态（例如，可以通过多条路径到达的状态，但是具有不同的开销）不会被保留。相反，开销最低、最有希望以及在启发式方法下最接近重复节点的目标状态的节点则被保留。

 优点：可以通过回溯到开放列表中的节点，从错误、假线索、死胡同中恢复。如果要寻找其他解的话，可以重新考虑开放列表中的节点的子节点。如果按照相反的顺序追踪封闭节点列表，并忽略到达死胡同的状态，则可以用来表示所找到的最优解。

 最佳优先搜索会维护开放节点列表的优先级队列。优先级队列具有的特征是可以插入元素、删除最大节点（或最小节点）。最佳优先搜索的效率取决于所使用的启发式度量方法的有效性。

## 3.4 集束搜索

 由于搜索树中的每一层只扩展最好的 *W* 个节点，如同形成一种薄的、聚焦的“光束”，，因此这种算法被称为**集束搜索**（beam search）。

 在集束搜索中，探索通过搜索树逐层扩展，但是每层只有最好的 *W* 个节点才会得到扩展。*W* 被称为集束宽度（beam width）。

 通过将搜索树深度的指数级内存开销降低到线性开销，集束搜索是对广度优先搜索的一种尝试改进方法。虽然集束搜索使用广度优先搜索建立搜索树，但是搜索树的每一层被分成至多*W* 个状态组成的切片，其中 *W* 是集束宽度。

 每一层切片（宽度为 *W*）的数目被限制为 1。当集束搜索扩展一层时，生成当前层状态的所有后继节点，将它们按照启发值递增的顺序（从左到右）排序，并将它们切分为多个切片（每个切片最多包含 *W* 个状态），然后只存储第一个切片，并扩展节点。当生成目标状态或内存不足（如前所述）时，集束搜索终止。

## 3.5 搜索算法的其他指标

算法尝试了许多可能的解，然后放弃了这些解。这样的算法可以很恰当地被称为**尝试性**（tentative）方法。与只检查一条路径的方法（如简单爬山法）形成对照的是，后一种方法被称为**不可撤回的**（irrevocable）方法。

## 3.6 知情搜索（第二部分）——找到最优解

### 3.6.1 分支定界法

“普通”分支定界法（**统一开销搜索或统一代价搜索**）该算法会按照递增的开销—更精确地说，是按照非递减的开销来寻找路径。

TSP 是**NP完全（NP-complete）问题**的一个实例。NP是一类问题的缩写，如果允许猜测的 话，那么这类问题可以在多项式时间内解决。P代表的是可以在确定性多项式时间（也就是没有 采用猜测时的多项式时间）内解决的一类问题。P类问题包括了计算机科学中许多为人熟知的问 题，如排序、确定图G是不是欧拉图等等。后面这个欧拉图确定问题可以换一种说法，即如果 图 G拥有一个环，那么这个环能遍历每条边一次且仅有一次（见第6章），或在带权重的图G 中找到一条从顶点i到j的最短路径。NP完全问题是NP类问题中最困难的问题。 NP完全问题看起来需要指数时间才能解决（在最坏的情况下）

NP完全问题彼此之间都是**多项式时间归约**的（polynomial-time reducible），即如果能够找 到任意一个NP完全问题的多项式时间算法，那么对于所有的NP完全问题也都会有多项式时间 算法。

### 3.6.2 使用低估计启发值的分支定界法

本节使用剩余距离的低估计启发值来增强分支定界法。

### 3.6.3 采用动态规划的分支定界法

通过最优性原理（Principle of Optimality）进行形式化：最优路径由最优子路径构建而成。

### 3.6.4  搜索

这种搜索算法采用了具有剩余距离估计值和动态规划的分支定界法。

## 3.7 知情搜索（第三部分）——高级搜索算法

### 3.7.1 约束满足搜索

在AI中，**问题简化**（problem reduction）是另一个重要方法。，即对更大或更复杂的问题进行求解时，可以识别出其中更小的可处理的子问题，这些子问题通过较少的步骤就可以解决。

### 3.7.2 与或树

用于问题简化的技术名为**与或树**。其目标是，通过应用以下规则，在给定的树中找到解的路径。

如果满足以下条件，那么节点是可解的。

（1）它是一个终止节点（一个基元问题）。

（2）它是一个非终止节点，并且其后继节点都是可解的与（AND）节点。

（3）它是一个非终止节点，后继节点是或（OR）节点，在这些或节点中，至少有一个可解。

类似地，在下列条件下，节点是不可解的。

（1）它是一个没有后继节点的非终止节点（没有运算符可应用的非基元问题）。

（2）它是一个非终止节点，后继节点是与（AND）节点，在这些与节点中，至少有一个不可解。或者

（3）它是一个非终止节点，后继节点是或（OR）节点，并且这些或节点都是不可解的。

### 3.7.3 双向搜索

双向搜索 （bidirectional search）的想法是在向前搜索目标状态的同时，从已知的目标状态向后搜索到起始 状态，以找到解的路径

在理论和实验上，凯因德尔和凯恩茨都证明了他们对双向搜索的改进是有效的——双向搜 索本身比以前我们所认为的更有效率，也更加没有风险。正如凯因德尔和凯恩茨所说，“传统的” 双向搜索试图存储来自向前和向后搜索两端的节点来寻求解。传统的方法将使用最佳优先搜索， 并且当两端试图“发现彼此”时，就会陷入指数级存储需求的泥潭。这就是所谓的**边界问题**

“非传统双向搜索方法”使用散列方案存储仅来自一端 的节点，这是因为“仅在一个方向搜索，首先存 储节点，然后在另一个方向搜索，这是可能的”。 这就是**周界搜索**